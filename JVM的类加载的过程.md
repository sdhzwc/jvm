类加载过程包括加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization），其中验证、准备、解析三个部分统称为连接（Linking）

### 1、加载

“加载（Loading）”阶段是整个“类加载（Class Loading）”过程中的一个阶段。在加载阶段，Java虚拟机需要完成以下三件事情：

1）通过一个类的全限定名来获取定义此类的二进制字节流。

2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 2、验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息被当作代码运行后不会危害虚拟机自身的安全。验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。

#### **2.1、文件格式验证**

第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：

1）是否以魔数0xCAFEBABE开头。

2）主、次版本号是否在当前Java虚拟机接受范围之内。

3）常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。

4）指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。

5）CONSTANT\_Utf8\_info型的常量中是否有不符合UTF-8编码的数据。

6）Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

7）......

该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

#### **2.2、元数据验证**

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：

1）这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。

2）这个类的父类是否继承了不允许被继承的类（被final修饰的类）。

3）如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。

4）类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。

5）......

#### **2.3、字节码验证**

第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：

1）保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。

2）保证任何跳转指令都不会跳转到方法体以外的字节码指令上。

3）保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。

4）......

#### **2.4、符号引用验证**

最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它以来的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容：

1）符号引用中通过字符串描述的全限定名是否能找到对应的类。

2）在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。

3）符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。

4）......

符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机 将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如： java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。

### 3、准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。注意这里有两个容易产生混淆的概念：一是这时候进行内存分配的仅包括类变量、而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中；二是这里所说的初始值“通常情况”下时数据类型的零值。下表是Java中所有基本类型的零值：

![](//upload-images.jianshu.io/upload_images/4337694-2775c56c23c9d0bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/546/format/webp)

### 4、解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

1）符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现地内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。

2）直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用时和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

解析阶段什么时候执行可以根据虚拟机的需要自行判定，只需要在执行ane-warray、 checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、 invokestatic、invokevirtual、ldc、ldc\_w、ldc2\_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。

### 5、初始化

类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。初始化阶段就是执行类构造器<clinit>()方法的过程。
