#### 前言

Java是运行在Java的虚拟机(JVM)中的，在初步学习Java时，我们都知道，编写的Java源代码会被编译器编译成`.class`的字节码文件。然后`ClassLoader`负责将这些`class`文件给加载到JVM中去执行。

我们跑Java程序，跟JVM脱不了干系。

JVM中提供了三层的ClassLoader：

- **Bootstrap classLoader**:主要负责加载核心的类库(java.lang.\*等)，构造ExtClassLoader和APPClassLoader。
  
- **ExtClassLoader**：主要负责加载jre/lib/ext目录下的一些扩展的jar。
  
- **AppClassLoader**：主要负责加载应用程序的主函数类
  

#### 双亲委派机制

通俗点讲，双亲可以浅显理解为父类，当.class文件将要被加载到JVM中时，会先交由AppClassLoader去加载，这时目前的ClassLoader不会去加载，而是一直向上，让父类去加载。

- 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。
- 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。
- 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70#pic_center)  
系统的ClassLoader只会**加载指定目录下的class文件**,如果想加载自己的class文件,那么就可以自定义一个ClassLoader。而且我们可以根据自己的需求，对class文件进行加密和解密。

需要注意的是，自定义加载器在“优先级”上，是最低的，所以简单来讲，**自定义的classLoader去加载自己的类，一定是父级们都没有办法加载的情况下。**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/440ccd753a22d73f5ca7fcd1bc0f38bb.png#pic_center)

#### Why 双亲委派

通过双亲委派模型机制，**类随着它的类加载器一起具备了一种带有优先级的层次关系**。

双亲委派这种机制能够避免核心类被篡改。例如：如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被[Bootstrap](https://so.csdn.net/so/search?q=Bootstrap&spm=1001.2101.3001.7020) classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），**所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入**。

再比如，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，在没有双亲委派模型的情况下，将会用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

并且，双亲委派这种机制能够**防止类的重复加载**。

#### 打破双亲委派模型的历史

**1.第一次破坏**

由于**双亲委派模型是在JDK1.2之后才被引入**的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对**已经存在的用户自定义类加载器的实现代码**，Java设计者引入双亲委派模型时不得不做出一些妥协。

在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，这是因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。

用户重写了loadClass才能实现自己的类加载逻辑。

**2.第二次破坏**

双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题：**越基础的类由越上层的加载器进行加载**

基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。

**如果基础类又要调用回用户的代码，那该么办？**

一个典型的例子就是`JNDI`服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。

为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：`线程上下文类加载器`(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

有了线程上下文加载器，`JNDI`服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。

**3.第三次破坏**

双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，与**热部署相关**，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。

### Tomcat是如何打破双亲委派机制的呢？

Tomcat自定义加载器重写了loadclass和findclass方法

Tomcat是先去本地目录加载，为了避免本地目录覆盖掉JRE的核心类，如java.lang包等，先尝试用ExtClassLoader加载，这样即能打破双亲委派机制，有避免了覆盖掉核心类。
